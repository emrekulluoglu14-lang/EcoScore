function doGet(e) {
  try {
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Skorlar");
    if (!sheet) {
      return ContentService.createTextOutput(JSON.stringify({
        success: false,
        error: "Skorlar sayfasÄ± bulunamadÄ±"
      })).setMimeType(ContentService.MimeType.JSON);
    }
    
    const rows = sheet.getDataRange().getValues();
    const dataRows = rows.length > 1 ? rows.slice(1) : [];
    
    dataRows.sort((a, b) => {
      const scoreA = Number(b[2]) || 0;
      const scoreB = Number(a[2]) || 0;
      return scoreA - scoreB;
    });
    
    const params = e?.parameter || {};
    const limit = parseInt(params.limit) || 10;
    const page = parseInt(params.page) || 1;
    
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedRows = dataRows.slice(startIndex, endIndex);
    
    function calculateBadge(score) {
      const numScore = Number(score) || 0;
      if (numScore >= 1000) return "ðŸ† ÅžAMPÄ°YON";
      if (numScore >= 500) return "â­ ALTIN";
      if (numScore >= 250) return "ðŸ¥ˆ GÃœMÃœÅž";
      if (numScore >= 100) return "ðŸ¥‰ BRONZ";
      return "ðŸŒ± YENÄ°";
    }
    
    const leaderboard = paginatedRows.map((row, index) => ({
      rank: startIndex + index + 1,
      name: row[1] || "Ä°simsiz",
      score: Number(row[2]) || 0,
      badge: row[3] || calculateBadge(row[2]),
      streak: Number(row[4]) || 0,
      lastUpdate: row[5] ? new Date(row[5]).toLocaleDateString('tr-TR') : "Bilinmiyor"
    }));
    
    const scores = dataRows.map(row => Number(row[2]) || 0);
    const totalScore = scores.reduce((a, b) => a + b, 0);
    const averageScore = scores.length > 0 ? Math.round(totalScore / scores.length) : 0;
    
    const response = {
      success: true,
      timestamp: new Date().toISOString(),
      leaderboard: leaderboard,
      pagination: {
        currentPage: page,
        totalPages: Math.ceil(dataRows.length / limit),
        totalUsers: dataRows.length,
        hasNext: endIndex < dataRows.length,
        hasPrev: startIndex > 0
      },
      stats: {
        totalScore: totalScore,
        averageScore: averageScore,
        maxScore: Math.max(...scores, 0),
        minScore: Math.min(...scores, 0)
      }
    };
    
    return ContentService
      .createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    return ContentService
      .createTextOutput(JSON.stringify({
        success: false,
        error: error.toString(),
        timestamp: new Date().toISOString()
      }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName("Skorlar");
    
    if (!sheet) {
      const newSheet = SpreadsheetApp.getActiveSpreadsheet().insertSheet("Skorlar");
      newSheet.appendRow(["ID", "Ä°sim", "Skor", "Rozet", "Streak", "Son GÃ¼ncelleme", "KayÄ±t Tarihi"]);
      return doPost(e);
    }
    
    if (!data.name || data.name.trim() === "") {
      throw new Error("Ä°sim alanÄ± boÅŸ olamaz");
    }
    
    const name = data.name.trim();
    const score = Number(data.score) || 0;
    const action = data.action || "update";
    const streak = Number(data.streak) || 0;
    
    const rows = sheet.getDataRange().getValues();
    
    if (rows.length === 0) {
      sheet.appendRow(["ID", "Ä°sim", "Skor", "Rozet", "Streak", "Son GÃ¼ncelleme", "KayÄ±t Tarihi"]);
    }
    
    let found = false;
    let rowIndex = -1;
    let currentScore = 0;
    let currentStreak = 0;
    
    for (let i = 1; i < rows.length; i++) {
      if (rows[i][1] === name) {
        found = true;
        rowIndex = i;
        currentScore = Number(rows[i][2]) || 0;
        currentStreak = Number(rows[i][4]) || 0;
        break;
      }
    }
    
    let newScore = score;
    let newStreak = streak || currentStreak;
    
    if (action === "increment") {
      newScore = currentScore + score;
    } else if (action === "decrement") {
      newScore = Math.max(0, currentScore - score);
    } else if (action === "register") {
      newScore = 0;
      newStreak = 0;
    } else if (action === "updateStreak") {
      newScore = currentScore;
      newStreak = streak;
    }
    
    function calculateBadge(score) {
      const numScore = Number(score) || 0;
      if (numScore >= 1000) return "ðŸ† ÅžAMPÄ°YON";
      if (numScore >= 500) return "â­ ALTIN";
      if (numScore >= 250) return "ðŸ¥ˆ GÃœMÃœÅž";
      if (numScore >= 100) return "ðŸ¥‰ BRONZ";
      return "ðŸŒ± YENÄ°";
    }
    
    const badge = calculateBadge(newScore);
    const now = new Date();
    
    if (found) {
      sheet.getRange(rowIndex + 1, 3).setValue(newScore);
      sheet.getRange(rowIndex + 1, 4).setValue(badge);
      sheet.getRange(rowIndex + 1, 5).setValue(newStreak);
      sheet.getRange(rowIndex + 1, 6).setValue(now);
    } else {
      const userId = Utilities.getUuid().slice(0, 8);
      sheet.appendRow([userId, name, newScore, badge, newStreak, now, now]);
    }
    
    const response = {
      success: true,
      message: "Ä°ÅŸlem baÅŸarÄ±lÄ±",
      data: {
        name: name,
        oldScore: found ? currentScore : 0,
        newScore: newScore,
        badge: badge,
        streak: newStreak,
        action: action,
        isNewUser: !found,
        timestamp: now.toISOString()
      }
    };
    
    return ContentService
      .createTextOutput(JSON.stringify(response))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    const errorResponse = {
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    };
    
    return ContentService
      .createTextOutput(JSON.stringify(errorResponse))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function doOptions() {
  return ContentService
    .createTextOutput()
    .setMimeType(ContentService.MimeType.JSON)
    .setHeader('Access-Control-Allow-Origin', '*')
    .setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS')
    .setHeader('Access-Control-Allow-Headers', 'Content-Type');
}
